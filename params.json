{"name":"v8.go","tagline":"V8 JavaScript engine bindings for Go","body":"v8.go\r\n=====\r\n\r\nV8 JavaScript engine bindings for Go.\r\n\r\nFeatures\r\n=======\r\n\r\n* Thread safe\r\n* Thorough and careful testing\r\n* Boolean, Number, String, Object, Array, Regexp, Function\r\n* Compile and run JavaScript\r\n* Save and load pre-compiled script data\r\n* Create JavaScript context with global object template\r\n* Operate JavaScript object properties and array elements in Go\r\n* Define JavaScript object template in Go with property accessors and interceptors\r\n* Define JavaScript function template in Go\r\n* Catch JavaScript exception in Go\r\n* Throw JavaScript exception by Go\r\n* JSON parse and generate\r\n* Powerful binding API\r\n\r\nInstall\r\n=======\r\n\r\nFor 'curl' user. please run this shell command:\r\n\r\n> curl -O https://raw.github.com/idada/v8.go/master/get.sh && chmod +x get.sh && ./get.sh v8.go\r\n\r\nFor 'wget' user. Please run this shell command:\r\n\r\n> wget https://raw.github.com/idada/v8.go/master/get.sh && chmod +x get.sh && ./get.sh v8.go\r\n\r\nNote: require Go version 1.2 and Git.\r\n\r\nHello World\r\n===========\r\n\r\nThis 'Hello World' program shows how to use v8.go to compile and run JavaScript code then get the result.\r\n\r\n```go\r\npackage main\r\n\r\nimport \"github.com/idada/v8.go\"\r\n\r\nfunc main() {\r\n\tengine := v8.NewEngine()\r\n\tscript := engine.Compile(\r\n\t\t[]byte(\"'Hello ' + 'World!'\"), \r\n\t\tnil, nil,\r\n\t)\r\n\tcontext := engine.NewContext(nil)\r\n\r\n\tcontext.Scope(func(cs v8.ContextScope) {\r\n\t\tresult := cs.Run(script)\r\n\t\tprintln(result.ToString())\r\n\t})\r\n}\r\n```\r\n\r\nFast Binding\r\n============\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\nimport \"reflect\"\r\nimport \"github.com/idada/v8.go\"\r\n\r\ntype MyType struct {\r\n\tId       int\r\n\tName     string\r\n\tData     map[string]int\r\n\tCallback func(a int, b string)\r\n}\r\n\r\nfunc (mt *MyType) Dump(info string) {\r\n\tfmt.Printf(\r\n\t\t\"Info: \\\"%s\\\", Id: %d, Name: \\\"%s\\\", Data: %v\\n\",\r\n\t\tinfo, mt.Id, mt.Name, mt.Data,\r\n\t)\r\n}\r\n\r\nfunc main() {\r\n\tengine := v8.NewEngine()\r\n\r\n\tglobal := engine.NewObjectTemplate()\r\n\r\n\tglobal.Bind(\"MyType\", MyType{})\r\n\r\n\tglobal.Bind(\"print\", func(v ...interface{}) {\r\n\t\tfmt.Println(v...)\r\n\t})\r\n\r\n\tglobal.Bind(\"test\", func(obj *v8.Object) {\r\n\t\traw := obj.GetInternalField(0).(*reflect.Value)\r\n\t\traw.Interface().(*MyType).Callback(123, \"dada\")\r\n\t})\r\n\r\n\tengine.NewContext(global).Scope(func(cs v8.ContextScope) {\r\n\t\tcs.Eval(`\r\n\t\t\tvar a = new MyType();\r\n\r\n\t\t\ta.Dump(\"old\");\r\n\r\n\t\t\ta.Id = 10;\r\n\t\t\ta.Name = \"Hello\";\r\n\t\t\ta.Data = {\r\n\t\t\t\t'x': 1,\r\n\t\t\t\t'y': 2\r\n\t\t\t};\r\n\t\t\ta.Dump(\"new\");\r\n\r\n\t\t\ta.Callback = function(a, b) {\r\n\t\t\t\tprint(a, b);\r\n\t\t\t}\r\n\r\n\t\t\ta.Callback(10, \"Hello\");\r\n\r\n\t\t\ttest(a);\r\n\t\t`)\r\n\t})\r\n}\r\n\r\n```\r\n\r\nPerformance and Stability \r\n=========================\r\n\r\nThe benchmark result on my iMac:\r\n\r\n```\r\nNewContext     249474 ns/op\r\nNewInteger        984 ns/op\r\nNewString         983 ns/op\r\nNewObject        1036 ns/op\r\nNewArray0        1130 ns/op\r\nNewArray5        1314 ns/op\r\nNewArray20       1666 ns/op\r\nNewArray100      3124 ns/op\r\nCompile         11059 ns/op\r\nPreCompile      11697 ns/op\r\nRunScript        1085 ns/op\r\nJsFunction       1114 ns/op\r\nGoFunction       1630 ns/op\r\nGetter           2060 ns/op\r\nSetter           2934 ns/op\r\nTryCatch        43097 ns/op\r\n```\r\n\r\nI write many test and benchmark to make sure v8.go stable and efficient.\r\n\r\nThere is a shell script named 'test.sh' in the project. \r\n\r\nIt can auto configure cgo environment variables and run test.\r\n\r\nFor example:\r\n\r\n```\r\n./test.sh . .\r\n```\r\n\r\nThe above command will run all of test and benchmark.\r\n\r\nThe first argument of test.sh is test name pattern, second argument is benchmark name pattern.\r\n\r\nFor example:\r\n\r\n```\r\n./test.sh ThreadSafe Array\r\n```\r\n\r\nThe above command will run all of thread safe test and all of benchmark about Array type.\r\n\r\nConcepts\r\n========\r\n\r\nEngine\r\n------\r\n\r\nIn v8.go, engine type is the wrapper of v8::Isolate.\r\n\r\nBecause V8 engine use thread-local storage but cgo calls may be execute in different thread. So v8.go use v8::Locker to make sure V8 engine's thread-local data initialized. And the locker make v8.go thread safe.\r\n\r\nYou can create different engine instance for data isolate or improve efficiency of concurrent purpose.\r\n\r\n```go\r\nengine1 := v8.NewEngine()\r\nengine2 := v8.NewEngine()\r\n```\r\n\r\nScript\r\n------\r\n\r\nWhen you want to run some JavaScript. You need to compile first.\r\n\r\nScripts can run many times or run in different context.\r\n\r\n```go\r\nscript := engine.Compile([]byte(`\"Hello \" + \"World!\"`), nil, nil)\r\n```\r\n\r\nThe Engine.Compile() method take 3 arguments. \r\n\r\nThe first is the code.\r\n\r\nThe second is a ScriptOrigin, it stores script's file name or line number offset etc. You can use ScriptOrigin to make error message and stack trace friendly.\r\n\r\n```go\r\nname := \"my_file.js\"\r\nreal := ReadFile(name)\r\ncode := \"function(_export){\\n\" + real + \"\\n}\"\r\norigin := engine.NewScriptOrigin(name, 1, 0)\r\nscript := engine.Compile(code, origin, nil)\r\n```\r\n\r\nThe third is a ScriptData, it's pre-parsing data, as obtained by Engine.PreCompile(). If you want to compile a script many time, you can use ScriptData to speeds compilation. \r\n\r\n```go\r\ncode := []byte(`\"Hello \" + \"World!\"`)\r\ndata := engine.PreCompile(code)\r\nscript1 := engine.Compile(code, nil, data)\r\nscript2 := engine.Compile(code, nil, data)\r\n```\r\n\r\nContext\r\n-------\r\n\r\nThe description in V8 embedding guide:\r\n\r\n> In V8, a context is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of V8. You must explicitly specify the context in which you want any JavaScript code to be run.\r\n\r\nIn v8.go, you can create many contexts from a V8 engine instance. When you want to run some JavaScript in a context. You need to enter the context by calling Scope() and run the JavaScript in the callback.\r\n\r\n```go\r\ncontext.Scope(func(cs v8.ContextScope){\r\n\tscript.Run()\r\n})\r\n```\r\n\r\nContext in V8 is necessary. So in v8.go you can do this:\r\n\r\n```go\r\ncontext.Scope(func(cs v8.ContextScope) {\r\n\tcontext2 := engine.NewContext(nil)\r\n\tcontext2.Scope(func(cs2 v8.ContextScope) {\r\n\r\n\t})\r\n})\r\n```\r\n\r\nMore\r\n----\r\n\r\nPlease read `v8_all_test.go` and the codes in `samples` folder.\r\n\r\n中文介绍\r\n========\r\n\r\nV8引擎的Go语言绑定。\r\n\r\n特性\r\n====\r\n\r\n* 线程安全\r\n* 详细的测试\r\n* 数据类型：Boolean, Number, String, Object, Array, Regexp, Function\r\n* 编译并运行JavaScript\r\n* 保存和加载预编译的JavaScript数据\r\n* 创建带有全局对象模板的Context\r\n* 在Go语言端操作和访问JavaScript数组的元素\r\n* 在Go语言端操作和访问JavaScript对象的属性\r\n* 用Go语言创建支持属性访问器和拦截器的JavaScript对象模板\r\n* 用Go语言创建JavaScript函数模板\r\n* 在Go语言端捕获JavaScript的异常\r\n* 从Go语言端抛出JavaScript的异常\r\n* JSON解析和生成\r\n* 强大的绑定功能\r\n\r\n安装\r\n====\r\n\r\n'curl'用户请运行以下脚本：\r\n\r\n> curl -O https://raw.github.com/idada/v8.go/master/get.sh && chmod +x get.sh && ./get.sh v8.go\r\n\r\n'wget'用户请运行以下脚本：\r\n\r\n> wget https://raw.github.com/idada/v8.go/master/get.sh && chmod +x get.sh && ./get.sh v8.go\r\n\r\n需求本地安装有Go 1.2和git命令。\r\n\r\nHello World\r\n===========\r\n\r\n以下是一段Hello World程序，用来展示v8.go如何编译和运行JavaScript并获得结果：\r\n\r\n```go\r\npackage main\r\n\r\nimport \"github.com/idada/v8.go\"\r\n\r\nfunc main() {\r\n\tengine := v8.NewEngine()\r\n\tscript := engine.Compile(\r\n\t\t[]byte(\"'Hello ' + 'World!'\"), \r\n\t\tnil, nil,\r\n\t)\r\n\tcontext := engine.NewContext(nil)\r\n\r\n\tcontext.Scope(func(cs v8.ContextScope) {\r\n\t\tresult := cs.Run(script)\r\n\t\tprintln(result.ToString())\r\n\t})\r\n}\r\n```\r\n\r\n快速绑定\r\n=======\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\nimport \"reflect\"\r\nimport \"github.com/idada/v8.go\"\r\n\r\ntype MyType struct {\r\n\tId       int\r\n\tName     string\r\n\tData     map[string]int\r\n\tCallback func(a int, b string)\r\n}\r\n\r\nfunc (mt *MyType) Dump(info string) {\r\n\tfmt.Printf(\r\n\t\t\"Info: \\\"%s\\\", Id: %d, Name: \\\"%s\\\", Data: %v\\n\",\r\n\t\tinfo, mt.Id, mt.Name, mt.Data,\r\n\t)\r\n}\r\n\r\nfunc main() {\r\n\tengine := v8.NewEngine()\r\n\r\n\tglobal := engine.NewObjectTemplate()\r\n\r\n\tglobal.Bind(\"MyType\", MyType{})\r\n\r\n\tglobal.Bind(\"print\", func(v ...interface{}) {\r\n\t\tfmt.Println(v...)\r\n\t})\r\n\r\n\tglobal.Bind(\"test\", func(obj *v8.Object) {\r\n\t\traw := obj.GetInternalField(0).(*reflect.Value)\r\n\t\traw.Interface().(*MyType).Callback(123, \"dada\")\r\n\t})\r\n\r\n\tengine.NewContext(global).Scope(func(cs v8.ContextScope) {\r\n\t\tcs.Eval(`\r\n\t\t\tvar a = new MyType();\r\n\r\n\t\t\ta.Dump(\"old\");\r\n\r\n\t\t\ta.Id = 10;\r\n\t\t\ta.Name = \"Hello\";\r\n\t\t\ta.Data = {\r\n\t\t\t\t'x': 1,\r\n\t\t\t\t'y': 2\r\n\t\t\t};\r\n\t\t\ta.Dump(\"new\");\r\n\r\n\t\t\ta.Callback = function(a, b) {\r\n\t\t\t\tprint(a, b);\r\n\t\t\t}\r\n\r\n\t\t\ta.Callback(10, \"Hello\");\r\n\r\n\t\t\ttest(a);\r\n\t\t`)\r\n\t})\r\n}\r\n\r\n```\r\n\r\n性能和稳定性 \r\n============\r\n\r\n以下是在我的iMac上运行benchmark的输出结果:\r\n\r\n```\r\nNewContext     249474 ns/op\r\nNewInteger        984 ns/op\r\nNewString         983 ns/op\r\nNewObject        1036 ns/op\r\nNewArray0        1130 ns/op\r\nNewArray5        1314 ns/op\r\nNewArray20       1666 ns/op\r\nNewArray100      3124 ns/op\r\nCompile         11059 ns/op\r\nPreCompile      11697 ns/op\r\nRunScript        1085 ns/op\r\nJsFunction       1114 ns/op\r\nGoFunction       1630 ns/op\r\nGetter           2060 ns/op\r\nSetter           2934 ns/op\r\nTryCatch        43097 ns/op\r\n```\r\n\r\n我写了很多的单元测试和基准测试用来确定v8.go是否稳定和高效。\r\n\r\n项目根目录下有一个叫'text.sh'的shell脚本。这个脚本可以自动配置CGO的环境变量并运行v8.go的测试。\r\n\r\n举个例子:\r\n\r\n```\r\n./test.sh . .\r\n```\r\n\r\n以下命令将执行所以单元测试和基准测试。\r\n\r\ntest.sh的第一个参数是单元测试的名称匹配模式，第二个参数是基准测试的名称匹配模式。\r\n\r\n再举个例子:\r\n\r\n```\r\n./test.sh ThreadSafe Array\r\n```\r\n\r\n以上命令将运行所有线程安全相关的单元测试和所有Array相关的基准测试。\r\n\r\n概念\r\n====\r\n\r\nEngine\r\n------\r\n\r\n在v8.go中，Engine类型是对象v8::Isolate的封装。\r\n\r\n因为V8引擎使用线程相关的存储机制用来优化性能，但是CGO调用可能会在不同的线程里执行。所以v8.go使用v8::Locker来确定V8引擎的线程数据有初始化，并确保v8.go是线程安全的。\r\n\r\n你可以创建多个引擎实例用来隔离数据和优化并发效率。\r\n\r\n```go\r\nengine1 := v8.NewEngine()\r\nengine2 := v8.NewEngine()\r\n```\r\n\r\nScript\r\n------\r\n\r\n当你要运行一段JavaScript代码前，你需要先把它编译成Script对象。\r\n\r\n一个Script对象可以在不同的Context中运行多次。\r\n\r\n```go\r\nscript := engine.Compile([]byte(`\"Hello \" + \"World!\"`), nil, nil)\r\n```\r\n\r\nEngine.Compile()方法需要三个参数。\r\n\r\n第一个参数是所要编译的JavaScript代码。\r\n\r\n第二个参数是一个ScriptOrigin对象，其中存储着脚本对应的文件名和行号等。你可以用ScriptOrigin来让错误信息和栈跟踪信息更友好。\r\n\r\n```go\r\nname := \"my_file.js\"\r\nreal := ReadFile(name)\r\ncode := \"function(_export){\\n\" + real + \"\\n}\"\r\norigin := engine.NewScriptOrigin(name, 1, 0)\r\nscript := engine.Compile(code, origin, nil)\r\n```\r\n\r\n第三个参数是一个ScriptData对象，它是Engine.PreCompile()方法预解析脚本后得到的数据。如果有一段代码你需要反复编译多次，那么你可以先预解析后，用ScriptData来加速编译。\r\n\r\n```go\r\ncode := []byte(`\"Hello \" + \"World!\"`)\r\ndata := engine.PreCompile(code)\r\nscript1 := engine.Compile(code, nil, data)\r\nscript2 := engine.Compile(code, nil, data)\r\n```\r\n\r\nContext\r\n-------\r\n\r\nV8嵌入指南中的解释:\r\n\r\n> In V8, a context is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of V8. You must explicitly specify the context in which you want any JavaScript code to be run.\r\n\r\n在v8.go中，你可以从一个Engine实例中创建多个上下文。当你需要在某个上下文中运行一段JavaScript时，你需要调用Context.Scope()方法进入这个上下文，然后在回调函数中运行JavaScript。\r\n\r\n```go\r\ncontext.Scope(func(cs v8.ContextScope){\r\n\tcs.Run(script)\r\n})\r\n```\r\n\r\n上下文在V8中是可以嵌套的。所以v8.go中你可以这样做：\r\n\r\n```go\r\ncontext.Scope(func(cs v8.ContextScope) {\r\n\tcontext2 := engine.NewContext(nil)\r\n\tcontext2.Scope(func(cs2 v8.ContextScope) {\r\n\r\n\t})\r\n})\r\n```\r\n\r\n更多\r\n----\r\n\r\n请阅读`v8_all_test.go`以及`samples`目录下的示例代码。\r\n","google":"UA-46130857-1","note":"Don't delete this file! It's used internally to help with page regeneration."}